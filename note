
+------------------------+
 |  Creating Repository  |
+------------------------+


 To create repository use git-init(1) command. The usage is:

   git init [-q|--quiet] [--bare] [--template=<template_directory] [--separate-git-dir <git_dir>] [--shared[=<permissions>]] directory

 If the $GIT_DIR environment variable is set then it specifies a path to use instead of ./.git for the base repository.

 If the object storage directory is specified via the $GIT_OBJECT_DIRECTORY environment variable then the sha1 directories 
 are created underneath - otherwise the default $GIT_DIR/objects directory is used. 

 Running git init in existing repository is safe, it will not overwrite an existing files. The primary reason for re-running git init
 is to pick up newly added templates or move the repository to another place if `--separate-git-dir` is given.
 
 After creation remote added in followed format:

  #ssh
  git clone git@git.test.o:root/shma.git    
                          ^ user

  #http
  git clone https://github.com/olegse/shma.git


 Note that user is always "git".

 In Git, "origin" is a shorthand name for the remote repository that a project was
 originally cloned from. It is used then instead of that original repository's URL.
 It is a standard convention.

 To add an origin to current directory
	git remote add origin <remote> <repository> <url>

 To get remote origin url:
  git remote get-url
 
 Setting up repository:
  git remote set-url <name> <url>		# if it already exist

 Remote should be set to a upstream branch with: 

  git push --set-upstream origin <branch>


 https://devconnected.com/how-to-set-upstream-branch-on-git/

 Downloading objects and refs from another repository:
    what the fuck is that?

 https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git



+--------------------------+
|  Cloning a repository   |
+-------------------------+

  Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using 
  `git branch -r'), and creates and checks out an initial branch that is forked from the cloned repository's currently active branch.

  Each file in the working directory can be either "tracked" or "untracked". "Tracked" files are files that were in the last snapshot; they can be 
  unmodified, modified, or staged. "Untracked" files are everything else - any files in the working directory that were not in the last snapshot
  and are not in the staging area. When the repository is first time cloned all the files are tracked and unmodified because they were just checked
  out and not yet edited. Once editied Git sees the files as modified, since it was changed since the last commit. All modified files should be staged
  and commited therefore reseting the cycle to it's start.


+-------------------------------+
 | Checking status of the files |
+-------------------------------+

  git status will display the differences between the index file and the current HEAD commit (files that can be directly commited,
  and paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git,
  and are not ignored by gitignore(5) (files that should be staged first. You can use `-v' to see a textual changes to be comitted and
  `-vv' to show also not staged changes. When used with the `-s' or `--short' options short letter codes are used to describe file status:
  A (added), D (deleted), R (renamed), M (modified).

  `git diff' will show changes between the working tree and the index or a tree, changes between two trees, changes between two blob objects,
  or changes between two files on disk. The usage is:
    $ git diff [options] [<commit>] [--] [<path>...]
    $ git diff [options] --cached [<commit>] [--] [<path>...]. 

  To compare files in working directory with files in the staging area run `git diff` without arguments. To see what is staged and
  will go to the next commit run:
   git diff --cached

  You can specify mode parameter with `--untracked-files` to display no untracked files with `no`, untracked files and directories with
  `normal` or also show individual files in untracked directories with `all` parameter.
 

+---------------------------+
|   Tracking new files      |
+---------------------------+


  Untracked files are added with `git add' command. It will update the index using the current content found in the working tree,
  to prepare content staged for the next commit. It typically adds the current content of existing paths as whole, but with some
  options it can also be used to add content with only part of changes made to the working tree files applied, or remove paths
  that do not exist in the working tree anymore.

  The "index" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the
  next commit. Thus after making any chagnes to the working tree, and before running the commit command, `git add' must be used
  to add any new or modified files. 

  Use `--force` option to override .gitignore settings. To test what is added run `git add --dry-run(-n)'. Files can be also
  added interactively with `--interactive' option.

  With `git commit --all(-a)' stage all the tracked files.

  To track an empty directory use ".gitkeep" file.


+-----------------------+
|      Ignoring files   |
+-----------------------+

  To exclude files from staging (such as logs, executables etc.) create a file listing patterns to match them named `.gitignore'.
  Lines strarting from '#' are comments, otherwise standard glob patterns are applied. Patterns ended by '/' specify a directory.
  The condition can be negotiated by prepending a pattern with '!'.
  
  .gitignore file is read each time when `git status` or `git add` is invoked.

  There is also an exclude files in the exclude directories (i.e., .git/info/exclude)
 
  To check ignore files, use on of the:
    
    git check-ignore [-v] *       # tool to debug gitignore /exclude files
    git ls-files --others --exclude-from=.git/info/exclue
    git status --ignored

  `git check-ignore` expects a file name as an argument and will report back if it was ignored or not.


  
 https://www.atlassian.com/git/tutorials/saving-changes/gitignore
 ++++

+------------------+
|  Listing files   |
+------------------+

  git-ls-files command is used to show information about files in the working tree

+------------------+
|    Branches        |
+--------------------+

  To list all the branches, run:
  	$ git branch -a


+----------------------------+
|   Environment variables    |
+----------------------------+

 	$GIT_DIR
  $GIT_OBJECT_DIRECTORY
	$GIT_TEMPLATE_DIR


 Files:

 	/etc/gitconfig
	~/.gitconfig
	.git/config


+-------------------------------+
| Configuration File Directives |
+-------------------------------+
 name = 
 email = 

+=============================+
|         Git Runner          |
+----------------------------+
  git-runner https://docs.gitlab.com/runner/configuration/advanced-configuration.html
